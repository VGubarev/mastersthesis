\chapter{Псевдокод алгоритмов работы с мультиплексором событий в разделяемой памяти}\label{sec:app:1}

\begin{algorithm}[!h]
\caption{Псевдокод процедуры получения оповещений в мультиплексоре событий}
\label{appendix91:ReceiverCode}
\begin{lstlisting}[frame=tlrb]
void MutliplexerServer::handle_signals() {
	// Шаг 1. Если в futex записан 0, значит, нет оповещений для обработки. Тогда процесс переходит в состояние сна.
	m_mux->wait();
	// Шаг 2. Атомарно получить актуальное значение futex и установить вместо него 0.
	int32_t futex = atomic_exchange(&m_futex, 0);
	// Шаг 3. Подсчитать количество установленных битов в числе, чтобы не выполнять линейное сканирование всех 32 битов.
	uint8_t cnt = popcnt(futex);
	for (uint8_t i = 0; i < cnt; i++) {
		// Шаг 4. Для каждого бита futex проверить соответствующие ему сигнальные числа.
		uint8_t f = get_unset_lsb(&futex);
		// Шаг 5. Атомарно получить значение сигнального числа и записать в него 0.
		int64_t signal = atomic_exchange(&m_signal[f], 0);
		uint8_t nsignals = popcntl(signal);
		// Шаг 6. Для каждого найденного сигнала запустить его обработку.
		for (uint8_t j = 0; j < nsignals; j++) {
			uint8_t s = get_unset_lsb(&signal);
			this->handle_signal(i * 64 + s);
		}
	}
}

// Выполняет обработку соединения, которому ранее был выдан номер id
void MultiplexerServer::handle_signal(Signal id);

// Возвращает количество выставленных битов в числе
uint8_t popcnt(int32_t value);
uint8_t popcntl(int64_t value);

// Сбрасывает младший бит числа и возвращает его позицию.
uint8_t get_unset_lsb(uint32_t & value);
uint8_t get_unset_lsb(uint64_t & value);
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Псевдокод процедуры оповещения процесса}
\label{appendix91:SignalCode}
\begin{lstlisting}[frame=tlrb]
void Multiplexer::notify(Signal id) {
	// Шаг 1. Выставить нужный бит в одном из сигнальных чисел в массиве. Число находится как результат деления номера соединения на 64, т.е. число от 0 до 31, позиция бита как остаток от деления номера соединения на 64.
	m_signal[id / Multiplexer::c_signals_per_chunk].fetch_or(1 << id % Multiplexer::c_signals_per_chunk);
    // Шаг 2. Выставить бит futex, соответствующий сигнальному числу. Позиция нужного бита находится как результат деления нмоера соединения на 64, т.е. число от 0 до 31.
	uint32_t futex = m_futex.fetch_or(1 << id / Multiplexer::c_signals_per_chunk);
	if (!futex) {
		// Шаг 3. Если предыдущее значение futex было 0, то попытаться разбудить один процесс, спящий на futex, системным вызовом futex.
		this->wakeup();
	}
}
\end{lstlisting}
\end{algorithm}

%
%В приложениях рисунки, таблицы и другие подобные элементы нумеруются по приложениям с соответствующим префиксом. Проверим это.
%
%Листинг~\ref{lst4:apx} должен иметь номер А.1.
%
%\begin{algorithm}[!h]
%\caption{Исходный код и флоат \texttt{algorithm}}\label{lst4:apx}
%\begin{lstlisting}
%public class HelloWorld {
%    public static void main(String[] args) {
%        System.out.println("Hello, world!");
%    }
%}
%\end{lstlisting}
%\end{algorithm}
%
%Рисунок~\ref{fig2:apx} должен иметь номер A.1.
%
%\begin{figure}[!h]
%\caption{Пример рисунка}\label{fig2:apx}
%\centering
%\begin{tikzpicture}[scale=0.7]
%\draw[thick,->] (0,0)--(3.5,0);
%\draw[thick,->] (0,0)--(0,3.5);
%\draw[very thick, red] (0,0)--(3,3);
%\draw[dashed] (3,0)--(3,3);
%\draw[dashed] (1.5,0)--(1.5,1.5);
%\end{tikzpicture}
%\end{figure}
%
%Таблица~\ref{tab3:apx} должна иметь номер A.1.
%
%\begin{table}[!h]
%\caption{Таблица умножения с помощью \texttt{tabularx} (фрагмент)}\label{tab3:apx}
%\centering
%\begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
%-- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
%1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
%2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
%3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
%4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
%\end{tabularx}
%\end{table}
%
%Заодно проверим нумерованные и ненумерованные перечисления. Ненумерованные:
%\begin{itemize}
%    \item пункт А;
%    \item пункт Б;
%    \item пункт В.
%\end{itemize}
%
%Нумерованные списки нескольких уровней:
%\begin{enumerate}
%    \item первый элемент;
%    \item второй элемент с подэлементами:
%    \begin{enumerate}
%        \item первый подэлемент;
%        \item второй подэлемент;
%        \item третий подэлемент.
%    \end{enumerate}
%    \item третий элемент;
%    \item четвертый элемент;
%    \item пятый элемент;
%    \item шестой элемент;
%    \item седьмой элемент;
%    \item восьмой элемент;
%    \item девятый элемент;
%    \item десятый элемент.
%\end{enumerate}
%
%\chapter{Еще один пример приложения с неимоверно длиннющим названием для тестирования переносов}\label{sec:app:2}
%
%Проверим на примере таблиц, что нумерация в приложениях~--- по приложениям.
%Таблица~\ref{tab3:apx2} должна иметь номер Б.1.
%
%\begin{table}[!h]
%\caption{Таблица умножения с помощью \texttt{tabularx} (фрагмент)}\label{tab3:apx2}
%\centering
%\begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
%-- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
%1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
%2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
%3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
%4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
%\end{tabularx}
%\end{table}
%
%\chapter{Пример огромного листинга}
%
%\begin{lstlisting}[caption={Пример большого листинга},label={lstX}]
%import java.util.*;
%
%public class Example {
%    static int[] restoreOutgoing(int[] g, int[] outgoing,
%                                 int vertex, int mask) {
%        int[] rv = new int[1 + Integer.bitCount(mask)];
%        int n = g.length;
%        int current = rv.length - 1;
%        while (true) {
%            rv[current] = vertex;
%            if (current == 0) {
%                if (vertex != 0) {
%                    throw new AssertionError();
%                }
%                return rv;
%            }
%            mask ^= 1 << (vertex - 1);
%            int prevMask = outgoing[mask] & g[vertex];
%            if (prevMask == 0) {
%                throw new AssertionError();
%            }
%            vertex = Integer.numberOfTrailingZeros(prevMask);
%            --current;
%        }
%    }
%
%    static int[] restoreIncoming(int[] g, int[] incoming,
%                                 int vertex, int mask) {
%        int[] rv = new int[1 + Integer.bitCount(mask)];
%        int n = g.length;
%        int current = 0;
%        while (true) {
%            rv[current] = vertex;
%            if (current == rv.length - 1) {
%                if (vertex != 0) {
%                    throw new AssertionError();
%                }
%                return rv;
%            }
%            mask ^= 1 << (vertex - 1);
%            int nextMask = incoming[mask] & g[vertex];
%            if (nextMask == 0) {
%                throw new AssertionError();
%            }
%            vertex = Integer.numberOfTrailingZeros(nextMask);
%            ++current;
%        }
%    }
%}
%\end{lstlisting}
%                