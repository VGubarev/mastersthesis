\chapter{ОБЗОР ПРЕДМЕТНОЙ ОБЛАСТИ И ПОСТАНОВКА ЦЕЛИ РАБОТЫ}

\startrelatedwork

\section{Методы межпроцессного взаимодействия}

Метод межпроцессного взаимодействия -- это способ осуществления взаимодействия процессов, находящихся на одном или разных физических узлах.

В Linux поддержаны следующие методы межпроцессного взаимодействия:
\begin{enumerate}
\item интернет-сокеты и сокеты домена Unix,
\item именованные и неименованные каналы,
\item очередь сообщений,
\item разделяемая память: SystemV и POSIX.
\end{enumerate}

Рассмотрим приведенные выше методы межпроцессного взаимодействия.

\subsection{Сокеты}

Сокет -- это программный интерфейс для обеспечения обмена данными между процессами. В зависимости от реализации интерфейса, позволяет взаимодействовать процессам как на разных физических узлах в составе сети, так и в пределах одного узла. Широко распространены два вида: TCP-сокеты и сокеты домена Unix. Первый работает через протокол TCP, второй -- использует некоторую внутреннюю реализацию последовательной гарантированной передачи данных.

\subsubsection{TCP-сокеты}
TCP-сокет -- интерфейс межпроцессного взаимодействия, использующий протокол TCP. Среди всех рассматриваемых методов только он позволяет взаимодействовать процессам на разных физических узлах в составе сети. В то же время, возможно межпроцессное взаимодействие и в пределах одного узла через механизм обратной петли, когда TCP-сообщение передается без каких-либо лишних операций в процесс-получатель, не покидая физического узла. В качестве точки соединения используется пара IP-адрес и порт.

TCP широко распространен. Сторонние системы чаще всего предоставляют именно TCP-интерфейс доступа к своим службам.

\subsubsection{Сокеты домена Unix}

Unix-сокет или IPC-сокет -- интерфейс межпроцессного взаимодействия в пределах одного узла, не использующий сетевого протокола. Может работать в разных режимах: передачи потока байт, датаграмм или последовательных пакетов. Первые два соответствуют протоколам TCP и UDP. Третий -- последовательный надежный канал для передачи датаграмм.

\subsection{Каналы}

\subsubsection{Неименованные каналы}

Неименованный канал -- однонаправленный метод межпроцессного взаимодействия для родственных процессов. Данные, записанные в неименованный канал, остаются там до момента считывания, либо до момента завершения ссылающихся на него процессов. Размер буфера ограничен.

\subsubsection{Именованные каналы}

Именованный канал отличается от неименованного тем, что представлен в виде файла, следовательно, доступен всем процессам ОС. Кроме того, время его жизни не ограничено временем жизни использующих его процессов.

\subsection{Очередь сообщений}

Очередь сообщений -- список сообщений, который хранится в пространстве ядра. Каждая очередь имеет свой уникальный идентификатор. Взаимодействие происходит путем вызовов записи и чтения сообщений.

\subsection{Разделяемая память}

Обычно в целях безопасности адресное пространство процесса изолировано от адресных пространств других процессов. В некоторых случаях, однако, может быть необходимо использовать совместно один и тот же сегмент памяти сразу несколькими процессами. Такая память называется разделяемой. На рисунке \ref{chapter11:ShMem} приведен пример использования разделяемой памяти двумя процессами.

\begin{figure}[!h]
\caption{Пример использования разделяемой памяти}
\label{chapter11:ShMem}
%\includegraphics{../../graphics/schemes/ShMemBasic}
\tikzfig{../../graphics/schemes/ShMemBasic}
\end{figure}

Существуют два интерфейса для доступа к разделяемой памяти. Более старый System V и более новый POSIX.

\subsubsection{System V}

Разделяемая память здесь является системным ресурсом, она представлена в ОС уникальным целочисленным ключом.

Интерфейс реализуется через набор системных вызовов и структур для работы с ним:
\begin{itemize}
\item shmget(key\_t key, size\_t size, int oflag) -- вызов для создания нового сегмента разделяемой памяти или использования существующего с ключом \textit{key} . Размер сегмента \textit{size}, флагb доступа и создания \textit{oflag};
\item shmat(int shmid, const void *shmaddr, int flag) -- подключение сегмента в адресное пространство процесса;
\item shmdt(const void *shmaddr) -- отключение сегмента от адресного пространства;
\item shmctl(int shmid, int cmd, struct shmid\_ds *buf) -- управление разделяемой памятью: изменение прав доступа, удаление, запрос статистики.
\end{itemize}

\subsubsection{POSIX}

Разделяемая память здесь является пользовательским ресурсом, в системе она представлена файлом.
Интерфейс реализуется через набор системных вызовов:
\begin{itemize}
\item shm\_open(const char *name, int oflag, mode\_t mode) -- открывает файл для разделяемой памяти (аналог shmget). В отличие от обычного вызова open, открытый таким образом файл не синхронизируется с диском;
\item shm\_unlink(const char *name) -- удаляет файл (аналог shmctl);
\item ftruncate(int fd, off\_t length) -- задает размер файла;
\item fstat(int fd, struct stat *statbuf) -- статистика о файле (аналог shmctl);
\item mmap(void *addr, size\_t length, int prot, int flags, int fd, off\_t offset) -- отображение файла в памяти (аналог shmat);
\item munmap(void *addr, size\_t length) -- отключает отображенный сегмент от адресного пространства процесса (аналог shmdt).
\end{itemize}

\subsubsection{Разница между System V и POSIX}
Оба интерфейса предлагают аналогичные возможности. Разница состоит в предоставлении ресурса в системе. Также, в POSIX интерфейсе сегмент разделяемой памяти будет уничтожен, когда будет завершен последний процесс, отображающий его в память, а файл полностью удален. Это свойство полезно на случай непредвиденного завершения процессов, например, в результате программного дефекта.

\subsection{Сравнение методов межпроцессного взаимодействия}

Приведенные выше методы можно разделить на группы по двум критериям:
\begin{itemize} 
\item способности к взаимодействию с удаленными процессами, то есть с процессами на других физических узлах;
\item использованию ядра ОС для осуществления межпроцессного взаимодействия.
\end{itemize}

Среди всех представленных методов только TCP-сокеты позволяют взаимодействовать как процессам на разных физических узлах, так и на одном узле, используя один и тот же интерфейс. Поэтому разумно использовать именно этот метод в качестве базового для межпроцессного взаимодействия.

Все приведенные методы, за исключением разделяемой памяти, при межпроцессном взаимодействии используют ядро операционной системы. Использование ядра существенно увеличивает временную задержку на передачу данных. Как минимум, из-за двойного копирования данных, перехода между пользовательским режимом и режимом ядра (см. рисунок \ref{chapter11:KernelUsage}).
Разделяемая память же позволяет осуществлять взаимодействие напрямую через пользовательское пространство.

\begin{figure}[!h]
\caption{Общая схема межпроцессного взаимодействия при использовании ядра ОС}
\label{chapter11:KernelUsage}
\tikzfig{../../graphics/schemes/KernelUsage}
\end{figure}

Однако, сама по себе разделяемая не предоставляет возможностей для синхронизации процессов, не имеет механизма оповещения об изменении состояния разделяемой памяти. Для этого необходимо рассмотреть методы синхронизации процессов.

\section{Методы синхронизации процессов}

Методы синхронизации процессов нужны, чтобы корректно передавать данные между процессами через разделяемую память, например, не допускать состояния гонки. Можно выделить два класса методов: примитивы синхронизации и атомарные операции. Примитивы синхронизации зачастую используют в своих алгоритмах атомарные операции.

\subsection{Примитивы синхронизации}

В Linux на уровне ядра ОС поддержаны следующие примитивы межпроцессной синхронизации:
\begin{enumerate}
\item System V семафоры;
\item futex -- \textbf{f}ast \textbf{u}serspace mu\textbf{tex}.
\end{enumerate}

В свою очередь, futex служит основой для более продвинутых примитивов синхронизации. Среди них:
\begin{enumerate}
\item POSIX-семафор;
\item mutex -- взаимное исключение;
\item read/write-mutex -- взаимное исключение для одного писателя и множества читателей;
\item spinlock -- взаимное исключение методом холостого ожидания (busy wait);
\item условная переменная -- оповещение о наступлении события и ожидание события.
\end{enumerate}

Рассмотрим их подробнее.

\subsubsection{futex}

Futex \cite{FutexOrigins} -- это низкоуровневый механизм блокировок в пользовательском пространстве. В основном, операции с ним производится с помощью атомарных инструкций в пользовательском пространстве. Ядро применяется для ожидания и диспетчеризации использующих futex процессов.

В пользовательской памяти futex -- это 4-байтное число, выровненное также на 4 байта. Он может располагаться в собственном адресном пространстве процесса и использоваться для синхронизации потоков процесса, а может и в разделяемой памяти и отвечать за синхронизацию разных процессов в пределах одного физического узла. Алгоритм работы с ним устанавливается пользователем. В нужных сценариях алгоритма используется ядро ОС для разрешения состязательности, задач ожидания и диспетчеризации.

\subsubsection{Семафоры}

Семафор -- это примитив синхронизации на основе целочисленного счетчика. Поддерживает две операции: увеличение значения счетчика и уменьшение. Уменьшение до нуля приводит к добавлению процесса в очередь ожидания семафора. Увеличение от нуля -- к пробуждению одного из потоков из очереди ожидания.

В Linux представлены два интерфейса семафоров: System V и POSIX.

\paragraph{POSIX}

Реализованы через futex. Представляют из себя целое знаковое число. Процедуры \textit{sem\_post()} и \textit{sem\_wait()} используются для увеличения и уменьшения значения семафора на единицу соответственно. Первая также пробуждает процесс из очереди ожидания семафора, если необходимо, вторая -- добавляет процесс в очередь ожидания, если значение семафора равно нулю или стало равно нулю после уменьшения значения.
POSIX-семафоры представлены в двух видах: именованные и неименованные. Первые идентифицируются файлом, вторые располагаются в адресном пространстве процесса или разделяемой памяти.

\paragraph{System V}

Реализованы в ядре ОС. Идентифицируются целочисленным ключом в пределах одной ОС. Имеют возможность контролировать доступ к операциям над семафором. В отличие от POSIX-семафоров позволяет менять состояние семафора больше, чем на единицу.

\subsubsection{Взаимные исключения}

Взаимное исключение -- примитив синхронизации для обеспечения эксклюзивного доступа к данным, защищенным этим примитивом. Существует несколько вариантов: обычный -- mutex, рекурсивный -- recursive mutex, с одновременным доступом нескольких читателей -- read/write-mutex. По определению, mutex может освободить только тот поток, который его занял. Рекурсивность -- возможность владельца взаимного исключения захватывать вновь.

В Linux реализованы через futex. Предоставляются посредством библиотеки \textit{pthread}.

\paragraph{Mutex}
Классический механизм взаимного исключения. Представлен платформо-зависимым типом данных \textit{pthread\_mutex\_t} Используется через семейство функций библиотеки \textit{pthread} -- \textit{pthread\_mutex\_*}.

\paragraph{RW-Mutex}
Версия взаимного исключения, допускающая совместное нахождение в критической секции нескольких читателей, но требующая эксклюзивного доступа для писателя. Представлена платформо-зависимым типом данных \textit{pthread\_rwlock\_t} Используется через семейство функций библиотеки \textit{pthread} -- \textit{pthread\_rwlock\_*}.

\paragraph{Spinlock}
Реализация механизма взаимного исключения с использованием механизма холостого ожидания. Взятие блокировки состоит в изменение значения переменной на условные ''свободно`` и ''занято``, а ожидание осуществляется -- в непрерывном циклическом ожидании состояния ''свободно``.

\subsubsection{Условная переменная}

Условная переменная -- сигнальный примитив синхронизации. Обеспечивает блокирование одного или нескольких потоков до наступления события о выполнения предиката. Поток, меняющий параметры предиката, должен сигнализировать об этом через условную переменную, чтобы ожидающие потоки были разбужены. Представлена платформо-зависимым типом данных \textit{pthread\_cond\_t}. Используется через семейство функций библиотеки \textit{pthread} -- \textit{pthread\_cond\_*}. Условная переменная используется вместе с mutex, который обеспечивает синхронизированный доступ к параметрам предиката и другим данным.

В Linux примитив также реализован через futex.

\subsubsection{Сравнение методов межпроцессной синхронизации}

Наиболее универсальный из рассмотренных классических примитивов синхронизации -- это семафор. Используя его можно реализовать как взаимное исключение, так и условную переменную. Он подходит для решения задач читателей и писателя и производителя и потребителей), как и комбинация условной переменной с mutex.

Как можно заметить, почти все рассмотренные примитивы в Linux реализованы через futex. Он может быть полезен при разработке своих собственных специализированных методов межпроцессной синхронизации \cite{FutexesAreTricky}.

\subsection{Атомарные операции}

Атомарная операция -- это операция, которая выполняется исключительно целиком, либо не выполняется вовсе. В настоящей работе рассматриваются именно простейшие операции. Обычно они представлены в виде процессорных инструкций и префиксов к ним. Используются через стандартную библиотеку языка C++ как набор классов \textit{std::atomic}.

Виды атомарных операций:
\begin{enumerate}
\item load/store -- атомарные чтение или запись;
\item swap -- атомарно устанавливает значение переменной и возвращает старое значение;
\item compare-and-swap -- атомарное изменение значения переменной, если ее текущее состояние совпадает с ожидаемым;
\item fetch-and-(add/dec/or/and) -- атомарная арифметическая или логическая операция над переменной с возвращением предыдущего значения.
\end{enumerate}

Атомарные операции используются при разработке методов синхронизации и неблокирующих алгоритмов, структур данных с конкурентным доступом. Даже в простейшей реализации взаимного исключения, в spinlock, исполнение в критической секции требует двух атомарных операций на взятие и освобождение. Если внутри критической секции необходимо, например, выставить бит в 4-байтной переменной, то можно сделать это, используя атомарную операцию fetch-and-or. 

Вместе с futex они являются наиболее низкоуровневыми блоками для построения методов межпроцессной синхронизации.

\section{Обзор литературы}

\subsection{Научные работы}
Во множестве работ предлагаются методы эффективного межпроцессного взаимодействия, системы передачи сообщений между процессами в различных применениях. В подавляющем большинстве работ в качестве среды для передачи данных используется разделяемая память.

Авторы в работе \cite{7790679} предлагают гетерогенную систему для передачи сообщений по модели ''издатель/подписчики``. Посредством очереди разделяемой памяти данные передаются между процессами, написанными на разных языка: Python и C++. Синхронизация и ожидание данных осуществляется через семафор.

В работе \cite{ShMemTransportThesis} представлена система для передачи сообщений, использующая разделяемую память для взаимодействия процессов в пределах одного узла и TCP -- с удаленными процессами. Поддержаны взаимодействия как по модели ''точка-точка``, так и ``издатель/подписчики''. Система предоставляет единый интерфейс межпроцессного взаимодействия, то есть использование того или иного метода не требует изменения исходного кода программистом.

В параллельных вычислениях широко используется MPI -- Message Passing Interface. Это программный интерфейс для взаимодействия процессов посредством передачи сообщений. В ряде работ предлагаются различные методы межпроцессного взаимодействия на основе разделяемой памяти с целью увеличения производительности параллельных систем в различных реализациях MPI, например, MPICH2 \cite{10.1007/11846802_19, 8665755} или MVAPICH2 \cite{4100356, 4663761}.

В работе \cite{HPCInterCoreLinux} предлагается метод эффективного межпроцессного взаимодействия с использованием разделяемой памяти для встраиваемых многоядерных систем, где необходимы одновременно производительные и не ресурсоемкие методы.

Существуют работы об использовании разделяемой памяти для взаимодействия процессов в разных виртуальных машинах в пределах машины-хозяина \cite{IPCInterVirtualMachineShmem, IPCInterVirtualMachineShmemOptimizations, 10.1145/2847562, 10.1007/978-3-642-00955-6_7}. В том числе, работа \cite{234795}, в которой разделяемая память используется как для взаимодействия процессов на одном физическом узле, так и на разных узлах в пределах кластера через удаленный прямой доступ в память (RDMA), что требует специального оборудования. В работе \cite{7416013} авторы используют разделяемую память для передачи данных через сокеты (TCP и UDP) для повышения производительности взаимодействия виртуальных машин на одном физическом узле.

Эффективное межпроцессное взаимодействие также важно в роботизированных системах. Так, в работе \cite{5649358} предлагается система передачи сообщений по модели ''издатель/подписчики`` посредством UDP-мультивещания с целью добиться минимальной временной задержки на передачу данных. Метод межпроцессного взаимодействия через разделяемую память предлагается в работе \cite{Wang2019TZCEI}, где авторы предлагают систему передачи данных по модели ''издатель/подписчик`` с передачей управляющего блока данных через сокеты, а самих данных через разделяемую память без преобразования передаваемого объекта в поток байт.

В различных работах исследуется производительность механизмов операционных систем для межпроцессного взаимодействия. В работе \cite{MuxComparison} сравниваются системные мультиплексоры событий \textit{select, epoll и poll}. В работе \cite{AnalysisOfEventProcDesignPatterns} проведен анализ влияния специфики работы этих механизмов на производительность методов обслуживания соединений ''Лидер/Последователи`` и ``Полусинхронный/Полуасинхронный``. А в работе \cite{6298185} были предложены и исследованы модели этих методов обслуживания.
%В работах \cite{Smith2012DraftH, venkataraman2015evaluation} произведен анализ и сравнение различных методов межпроцессного взаимодействия в Linux: каналов, различных реализаций на основе разделяемой памяти, сокетов домена UNIX и TCP.
В работах \cite{Smith2012DraftH, venkataraman2015evaluation} в Linux показано превосходство методов межпроцессного взаимодействия на основе разделяемой памяти над каналами, TCP и сокетами домена Unix.
В работе \cite{8526899} исследуются механизмы пробуждения потоков для обслуживания асинхронных событий и предлагается метод существенного уменьшения временной задержки на пробуждение потока для обслуживания асинхронного события путем использования привилегированных возможностей аппаратного обеспечения.

\subsection{Коммерческие решения для передачи сообщений}

Наиболее известные высокопроизводительные решения для передачи сообщений между процессами -- это системы от компаний TIBCO \cite{TIBCO}, Informatica \cite{Informatica} и Solace \cite{Solace}. Они представляют собой целостные решения организации обмена сообщениями между процессами распределенной системы. Для передачи данных между процессами в пределах одного физического узла используют методы на основе разделяемой памяти.

\section{Значимость методов на основе разделяемой памяти в межпроцессном взаимодействия}

Исходя из выше перечисленного, методы на основе разделяемой памяти имеют большое значение в современных системах обмена сообщениями. Использование разделяемой памяти позволяет улучшить производительность межпроцессного взаимодействия. Это следует как из ее механизма работы, так и из множества работ других исследователей, использующих разделяемую память для эффективного межпроцессного взаимодействия различных прикладных областях.

\section{Важность единого интерфейса межпроцессного взаимодействия}

Крайне важно соблюдать единый и неизменный интерфейс межпроцессного взаимодействия. Внедрение новых методов межпроцессного взаимодействия не должно приводить к изменениям в пользовательском исходном коде. Поэтому методы, разрабатываемые в настоящей работе, должны соблюдать разработанный ранее интерфейс межпроцессного взаимодействия \cite{GubarevKMU18}.

\finishrelatedwork

\section{Критерий эффективности и постановка цели}

В настоящей работе критерием эффективности принята временная задержка на передачу данных. Чем она меньше, тем более эффективным считается метод межпроцессного взаимодействия, то есть критерий является инверсным.

Цель работы -- уменьшение временной задержки на передачу данных между процессами в пределах одного физического узла путем разработки и применения методов эффективного межпроцессного взаимодействия.
%
%Для достижения поставленной цели в работе необходимо разработать и реализовать новые эффективные методы межпроцессного взаимодействия. Они должны быть построены на основе очереди в разделяемой памяти и использовать более эффективные методы оповещения о появлении данных в этой разделяемой памяти, чем TCP.
%
%%В работе предлагаются новые методы эффективного межпроцессного взаимодействия. Данные методы построены на очереди в разделяемой памяти и используют мультиплексор в разделяемой памяти для оповещения процессов о появлении данных в очереди.
%
%%Из проведенного сравнения методов межпроцессного взаимодействия и синхронизации и обзора литературы следует, что сама по себе разделяемая память является очень производительным методом межпроцессного взаимодействия. 
%
%Проведено сравнение методов межпроцессного взаимодействия и синхронизации и обзор литературы. Из них следует, что разделяемая память является наиболее эффективным методом межпроцессного взаимодействия. Однако, она не предоставляет механизмов синхронизации и отслеживания событий в ней. Поэтому необходимо также разработать и реализовать эффективный метод оповещения о появлении данных в разделяемой памяти.
%
%%Проведено сравнение методов межпроцессного взаимодействия и синхронизации. Проведен обзор литературы. Из них следует, что 

%Для достижения поставленной в работе цели необходимо разработать и реализовать новые методы эффективного межпроцессного взаимодействия. Из проведенного в работе сравнения методов межпроцессного взаимодействия и синхронизации и обзора литературы следует, что наиболее производительным методом взаимодействия является взаимодействие через разделяемую память. Поэтому разрабатываемые методы должны быть построены на основе очереди сообщений в разделяемой памяти. Однако, очередь в разделяемой памяти сама по себе не предоставляет механизмов синхронизации и отслеживания поступления новых сообщений. Одним из способов решения этой задачи является использование протокола ТСР для оповещения принимающего процесса о появлении новых данных \cite{GubarevKMU18}. Эффективность данного подхода остается неясной. Поэтому в данной работе также ставилась цель разработать и реализовать альтернативный метод оповещения о появлении данных в разделяемой памяти и провести его сравнение с предложенным в \cite{GubarevKMU18} методом оповещения через ТСР.

Для достижения поставленной в работе цели необходимо разработать и реализовать новые методы эффективного межпроцессного взаимодействия. Из проведенного в работе сравнения методов межпроцессного взаимодействия и синхронизации и обзора литературы следует, что наиболее производительным методом взаимодействия является взаимодействие через разделяемую память. Поэтому разрабатываемые методы должны быть построены на основе очереди сообщений в разделяемой памяти. Однако, очередь в разделяемой памяти сама по себе не предоставляет механизмов синхронизации и отслеживания поступления новых сообщений. Одним из способов решения этой задачи является использование протокола ТСР для оповещения принимающего процесса о появлении новых данных \cite{GubarevKMU18}. Эффективность данного подхода остается неясной. Поэтому в данной работе также ставилась цель разработать и реализовать альтернативный метод оповещения о появлении данных в разделяемой памяти, экспериментально исследовать разработанные методы и сравнить их с разработанным в \cite{GubarevKMU18} методом оповещения через ТСР.

Новые методы должны следовать разработанному ранее интерфейсу межпроцессного взаимодействия и не требовать изменений в пользовательском коде для своего использования.

%Необходимо экспериментально исследовать разработанные методы межпроцессного взаимодействия и сравнить их с разработанным ранее методом с использованием разделяемой памяти и TCP для оповещения о появлении данных в очереди.

%Новые методы должны следовать разработанному ранее интерфейсу межпроцессного взаимодействия и не требовать изменений в пользовательском коде для своего использования.

