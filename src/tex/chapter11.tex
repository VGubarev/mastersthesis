\chapter{Обзор предметной области и постановка цели работы}

\startrelatedwork

\section{Методы межпроцессного взаимодействия}

Метод межпроцессного взаимодействия -- это способ осуществления взаимодействия процессов, находящихся на одном или разных физических узлах.

В Linux поддержаны следующие методы межпроцессного взаимодействия:
\begin{enumerate}
\item Интернет-сокеты и сокеты домена Unix.
\item именованные и неименованные каналы.
\item Очередь сообщений.
\item Разделяемая память: SystemV и POSIX.
\end{enumerate}

Рассмотрим приведенные выше методы межпроцессного взаимодействия.

\subsection{Сокеты}

Сокет -- это программный интерфейс для обеспечения обмена данными между процессами. В зависимости от реализации интерфейса, позволяет взаимодействовать процессам как на разных физических узлах в составе сети, так и в пределах одного узла. Широко распространены два вида, сокеты TCP и сокеты домена Unix. Первый работает через протокол TCP, второй -- использует некоторую внутреннюю реализацию канала связи, как и в TCP.

\subsubsection{TCP-сокеты}
TCP-сокет -- интерфейс межпроцессного взаимодействия, использующий протокол TCP. Среди всех рассматриваемых методов только он позволяет взаимодействовать процессам на разных физических узлах в составе сети. В то же время, возможно межпроцессное взаимодействие и в пределах одного узла через механизм обратной петли, когда TCP-сообщение передается без каких-либо излишних операций в процесс-получатель, не покидая физического узла. В качестве точки соединения используется пара IP-адрес и порт.

TCP широко распространен. Сторонние системы чаще всего предоставляют именно TCP-интерфейс доступа к своим службам.

\subsubsection{Сокеты домена Unix}

Unix-сокет или IPC-сокет -- интерфейс межпроцессного взаимодействия в пределах одного узла, не использующий сетевого протокола. Может работать в разных режимах: передачи потока байт, датаграмм или последовательных пакетов. Первые два соответствуют протоколам TCP и UDP. Третий -- последовательный надежный канал для передачи датаграмм.

\subsection{Каналы}

\subsubsection{Неименованные каналы}

Неименованный канал -- однонаправленный метод межпроцессного взаимодействия для родственных процессов. Данные, записанные в неименованный канал, остаются там до момента считывания, либо до момента завершения ссылающихся на него процессов. Размер буфера ограничен.

\subsubsection{Именованные каналы}

Именованный канал отличается от неименованного тем, что представлен в виде файла, следовательно, доступен всем процессам ОС. Кроме того, время его жизни не ограничено временем жизни использующих его процессов.

\subsection{Очередь сообщений}

Очередь сообщений -- список сообщений, который хранится в пространстве ядра. Каждая очередь имеет свой уникальный идентификатор. Взаимодействие происходит путем вызовов записи и чтения сообщений.

\subsection{Разделяемая память}

Обычно в целях безопасности адресное пространство процесса изолировано от других. В некоторых случаях, однако, может быть необходимо использовать совместно один и тот же сегмент памяти. Такая память называется разделяемой. На рисунке \ref{chapter11:ShMem} приведен пример использования разделяемой памяти двумя процессами.

\begin{figure}[!h]
\caption{Пример использования разделяемой памяти}
\label{chapter11:ShMem}
%\includegraphics{../../graphics/schemes/ShMemBasic}
\tikzfig{../../graphics/schemes/ShMemBasic}
\end{figure}

Существуют два интерфейса для доступа к разделяемой памяти. Более старый System V и более новый POSIX.

\subsubsection{System V}

Разделяемая память здесь является системным ресурсом, она представлена уникальным ключом в пределах ОС.

Интерфейс реализуется через набор системных вызовов и структур для работы с ним:
\begin{itemize}
\item shmget(key\_t key, size\_t size, int oflag) -- вызов для создания нового сегмента разделяемой памяти или использования существующего с ключом \textit{key} . Размер сегмента \textit{size}, флагb доступа и создания \textit{oflag};
\item shmat(int shmid, const void *shmaddr, int flag) -- подключение сегмента в адресное пространство процесса;
\item shmdt(const void *shmaddr) -- отключение сегмента от адресного пространства;
\item shmctl(int shmid, int cmd, struct shmid\_ds *buf) -- управление разделяемой памятью: изменение прав доступа, удаление, запрос статистики;
\end{itemize}

\subsubsection{POSIX}

Разделяемая память здесь является пользовательским ресурсом, она представлена файлом.
Интерфейс реализуется через набор системных вызовов:
\begin{itemize}
\item shm\_open(const char *name, int oflag, mode\_t mode) -- открывает файл для разделяемой памяти (аналог shmget). В отличие от обычного вызова open, открытый таким образом файл не синхронизируется с диском.
\item shm\_unlink(const char *name) -- удаляет файл (аналог shmctl);
\item ftruncate(int fd, off\_t length) -- задает размер файла;
\item fstat(int fd, struct stat *statbuf) -- статистика о файле (аналог shmctl);
\item mmap(void *addr, size\_t length, int prot, int flags, int fd, off\_t offset) -- отображение файла в памяти (аналог shmat);
\item munmap(void *addr, size\_t length) -- отключает отображенный сегмент от адресного пространства процесса (аналог shmdt).
\end{itemize}

\subsubsection{Разница между System V и POSIX}
Оба интерфейса предлагают аналогичные возможности. Разница состоит в предоставлении ресурса в системе, имени файла для POSIX или целом числе в System V. Также, в POSIX интерфейсе сегмент разделяемой памяти будет уничтожен, когда будет завершен последний процесс, отображающий его в память, а файл полностью удален. Это свойство полезно на случай непредвиденного завершения процессов, например, в результате программного дефекта.

\subsection{Сравнение методов межпроцессного взаимодействия}

Приведенные выше методы можно разделить на группы по трем критериям:
\begin{itemize} 
\item способности к взаимодействию с удаленными процессами, то есть с процессами на других физических узлах;
\item использованию ядра ОС для осуществления межпроцессного взаимодействия.
\end{itemize}

Среди всех представленных методов только TCP-сокеты позволяют взаимодействовать как процессам на разных физических узлах, так и на одном узле, используя один и тот же интерфейс. Поэтому разумно использовать именно этот метод в качестве базового метода межпроцессного взаимодействия.

Все приведенные методы, за исключением разделяемой памяти, при межпроцессном взаимодействии используют ядро операционной системы. Использование ядра существенно увеличивает временную задержку на передачу данных. Как минимум, из-за двойного копирования данных, перехода между пользовательским режимом и режимом ядра (см. рисунок \ref{chapter11:KernelUsage}).
Разделяемая память же позволяет осуществлять взаимодействие напрямую через пользовательское пространство.

\begin{figure}[!h]
\caption{Общая схема межпроцессного взаимодействия при использовании ядра ОС}
\label{chapter11:KernelUsage}
\tikzfig{../../graphics/schemes/KernelUsage}
\end{figure}

Однако, сама по себе разделяемая не предоставляет возможностей для синхронизации процессов, не имеет механизма оповещения об изменении состояния разделяемой памяти. Для этого необходимо рассмотреть методы синхронизации процессов.

\section{Методы синхронизации процессов}

Методы синхронизации процессов нужны, чтобы корректно передавать данные между процессами через разделяемую память, например, не допускать состояния гонки. Можно выделить два класса методов: примитивы синхронизации и атомарные операции. Примитивы синхронизации зачастую используют в своих алгоритмах атомарные операции.

\subsection{Примитивы синхронизации}

В Linux на уровне ядра ОС поддержаны следующие примитивы межпроцессной синхронизации:
\begin{enumerate}
\item System V семафоры;
\item futex -- \textbf{f}ast \textbf{u}serspace mu\textbf{tex}.
\end{enumerate}

В свою очередь, futex служит основой для более продвинутых примитивов синхронизации:
\begin{enumerate}
\item POSIX-семафора;
\item mutex -- взаимное исключение;
\item rw-mutex -- взаимное исключение для одного писателя и множества читателей.
\item spinlock -- взаимное исключение методом холостого ожидания (busy wait).
\item Условная переменная -- оповещение о наступлении события и ожидание события.
\end{enumerate}

Рассмотрим их подробнее.

\subsubsection{futex}

Futex \cite{FutexOrigins} -- это низкоуровневый механизм блокировок в пользовательском пространстве. В основном, операции с ним производится с помощью атомарных инструкций в пользовательском пространстве. Ядро применяется для ожидания и диспетчеризации использующих futex процессов.

В пользовательской памяти futex -- это 4-байтное число, выравненное также на 4 байта. Он может располагаться в собственном адресном пространстве процесса и использоваться для синхронизации потоков процесса, а может и в разделяемой памяти и отвечать за синхронизацию разных процессов в пределах одного физического узла. Алгоритм работы с ним устанавливается пользователем. В нужных сценариях алгоритма используется ядро ОС для разрешения состязательности, задач ожидания и диспетчеризации.

\subsubsection{Семафоры}

Семафор -- это примитив синхронизации на основе целочисленного счетчика. Поддерживает две операции: увеличение значения счетчика и уменьшение. Уменьшение до нуля приводит к добавлению процесса в очередь ожидания семафора. Увеличение от нуля -- к пробуждению одного из потоков из очереди ожидания.

В Linux представлены два интерфейса семафоров: System V и POSIX.

\paragraph{POSIX}

Реализованы через futex. Представляют из себя целое знаковое число. Процедуры \textit{sem\_post()} и \textit{sem\_wait()} используются для увеличения и уменьшения значения семафора, соответственно. Первая также пробуждает процессы в очереди ожидания семафора, если необходимо, вторая -- добавляет процесс в очередь ожидания, если после уменьшения значения семафора стало равно нулю или было равно  нулю.
POSIX-семафоры представлены в двух видах: именованные и неименованные. Первые идентифицируются файлом, вторые располагаются в адресном пространстве процесса или разделяемой памяти.

\paragraph{System V}

Реализованы в ядре ОС. Идентифицируются целочисленным ключом в пределах одной ОС. Имеют возможность контролировать доступ к операциям над семафором.

\subsubsection{Взаимные исключения}

Взаимное исключение -- примитив синхронизации для обеспечения эксклюзивного доступа к данным, защищенным этим примитивом. Существует несколько вариантов: обычный -- mutex, рекурсивный -- recursive mutex, с одновременным доступом нескольких читателей -- read/write-mutex. По определению, mutex может освободить только тот поток, который его занял.

В Linux реализованы через futex. Предоставляются посредством библиотеки \textit{pthread}.

\paragraph{Mutex}
Классический механизм взаимного исключения. Представлен платформо-зависимым типом данных \textit{pthread\_mutex\_t} Используется через семейство функций библиотеки \textit{pthread} -- \textit{pthread\_mutex\_*}.

\paragraph{RW-Mutex}
Версия взаимного исключения, допускающая совместное нахождение в критической секции нескольких читателей, но требующая эксклюзивного доступа для писателя. Представлена платформо-зависимым типом данных \textit{pthread\_rwlock\_t} Используется через семейство функций библиотеки \textit{pthread} -- \textit{pthread\_rwlock\_*}.

\paragraph{Spinlock}
Реализация механизма взаимного исключение с использованием механизма холостого ожидания. Взятие блокировки состоит в изменение значения переменной на условные "свободно" и "занято", а ожидание -- в непрерывном циклическом ожидании наступления состояния "свободно".

\subsubsection{Условная переменная}

Условная переменная -- примитив синхронизации. Обеспечивает блокирование одного или нескольких потоков до наступления события о выполнения предиката. Представлена платформо-зависимым типом данных \textit{pthread\_cond\_t}. Используется через семейство функций библиотеки \textit{pthread} -- \textit{pthread\_cond\_*}. Условная переменная используется вместе с mutex, который обеспечивает синхронизированный доступ к параметрам предиката и другим данным.

В Linux примитив также реализован через futex.

\subsection{Сравнение методов межпроцессной синхронизации}

\textbf{TBD: прямо сравнение? Выбрать нормальное название раздела}

Наиболее универсальный из рассмотренных примитивов синхронизации -- это семафор. Используя его можно реализовать как взаимное исключение, так и условную переменную. Он подходит для решения задачи читателей и писателя (или производителя и потребителей), как и комбинация условной переменной с mutex.

Как можно заметить, почти все рассмотренные примитивы в Linux реализованы через futex. Он может быть полезен при разработке своих собственных примитивов синхронизации \cite{FutexesAreTricky}.

\subsection{Атомарные операции}

Атомарная операция -- это операция, которая выполняется исключительно целиком, либо не выполняется вовсе. В настоящей работе рассматриваются именно простейшие операции. Они используются через стандартную библиотеку языка C++ как набор классов \textit{std::atomic}.

Виды атомарных операций:
\begin{enumerate}
\item load/store -- атомарные чтение или запись;
\item swap -- атомарно устанавливает значение переменной и возвращает старое значение;
\item compare-and-swap -- атомарное изменение значения переменной, если ее текущее состояние совпадает с ожидаемым;
\item fetch-and-(add/dec/or/and) -- атомарная арифметическая или логическая операция над переменной с возвращением предыдущего значения.
\end{enumerate}

Атомарные операции используются при разработке методов синхронизации и неблокирующих алгоритмов, структур данных с конкурентным доступом. Даже в простейшей реализации взаимного исключения, в spinlock, исполнение в критической секции требует двух атомарных операций на взятие и освобождение. Если внутри критической секции необходимо, например, выставить бит в 4-байтной переменной, то можно сделать это, используя атомарную операцию fetch-and-or. 

Вместе с futex они являются наиболее низкоуровневыми блоками для построения методов межпроцессной синхронизации.

\section{Предыдущая работа}

В ранних работах автора была разработана и реализована прикладная программная платформа для эффективного взаимодействия процессов \cite{GubarevKMU18, GubarevBachelorThesis}. Разработан и реализован метод эффективного межпроцессного взаимодействия посредством мультиплексора в разделяемой памяти \cite{GubarevKMU20}. Данный метод предоставляется через реализованную ранее прикладную программную платформу, то есть не требует со стороны программиста никаких изменений в программном коде для использования разработанного метода.
\textbf{TBD: может, убрать все цитирования ВКР? А еще мультиплексор -- это не предыдущая, а очень даже свежая работа.}

\section{Обзор литературы}

Методы эффективного процессного взаимодействия исследуются разными авторами в самых разных применениях.

Во множестве работ предлагаются методы межпроцессного взаимодействия, системы передачи сообщений для уменьшения временной задержки на передачу данных между процессами \cite{7790679, ShMemTransportThesis} в разных прикладных приложениях.

Так, например, существуют работы об использовании разделяемой памяти для взаимодействия процессов в разных виртуальных машинах в пределах машины-хозяина \cite{IPCInterVirtualMachineShmem, IPCInterVirtualMachineShmemOptimizations, 10.1145/2847562, 10.1007/978-3-642-00955-6_7}.

А также в робототехнике \cite{5649358, Wang2019TZCEI}.

В параллельных вычислениях с использованием MPI \cite{4100356, 10.1007/11846802_19, 4663761, 4625853, 8665755}.

Диссер \cite{HPCInterCoreLinux}. \textbf{TBD: подумать над оформлением}

Исследуется производительность механизмов операционных систем, участвующие в межпроцессном взаимодействии \cite{MuxComparison, Smith2012DraftH, 8526899}.

%\subsection{Коммерческие решения для передачи сообщений}
%
%Наиболее известные высокопроизводительные решения для передачи сообщений между процессами это системы от компаний TIBCO и Informatica. Они представляют собой целостные решения организации обмена сообщениями между процессами распределенной системы. 
%
%\subsection{TIBCO Messaging}
%
%
%\subsection{Informatica Ultra Messanging}

\textbf{TBD: конец раздела}
В значительной части работ, посвященных эффективному межпроцессному взаимодействию, рассматривается именно разделяемая память и методы межпроцессного взаимодействия на ее основе.

\section{Значимость методов на основе разделяемой памяти в межпроцессном взаимодействия}

\textbf{TBD: Таким образом, методы на основе разделяемой памяти...}

\section{Необходимость в едином интерфейса доступа к методам межпроцессного взаимодействия}

\textbf{TBD: Чтобы методами можно было пользоваться, нужен интерфейс, интерфейс был сделан, поэтому теперь все работает через него, включая и эту работу}

\finishrelatedwork

\section{Критерий эффективности и постановка цели работы}

\textbf{TBD: временная задержка на передачу данных}
\textbf{TBD: и ее цель -- ее уменьшение в сравнении с TCP}

\chapterconclusion

\textbf{TBD: выводы}