\chapter{Обзор предметной области и постановка цели работы}

\startrelatedwork

\section{Методы межпроцессного взаимодействия}

Метод межпроцессного взаимодействия -- это способ осуществления взаимодействия процессов, находящихся на одном или разных физических узлах.

В Linux поддержаны следующие методы межпроцессного взаимодействия:
\begin{enumerate}
\item Интернет-сокеты и сокеты домена Unix.
\item именованные и неименованные каналы.
\item Очередь сообщений.
\item Разделяемая память: SystemV и POSIX.
\end{enumerate}

Рассмотрим приведенные выше методы межпроцессного взаимодействия.

\subsection{Сокеты}

Сокет -- это программный интерфейс для обеспечения обмена данными между процессами. В зависимости от реализации интерфейса, позволяет взаимодействовать процессам как на разных физических узлах в составе сети, так и в пределах одного узла. Широко распространены два вида, сокеты TCP и сокеты домена Unix. Первый работает через протокол TCP, второй -- использует некоторую внутреннюю реализацию канала связи, как и в TCP.

\subsubsection{TCP-сокеты}
TCP-сокет -- интерфейс межпроцессного взаимодействия, использующий протокол TCP. Среди всех рассматриваемых методов только он позволяет взаимодействовать процессам на разных физических узлах в составе сети. В то же время, возможно межпроцессное взаимодействие и в пределах одного узла через механизм обратной петли, когда TCP-сообщение передается без каких-либо излишних операций в процесс-получатель, не покидая физического узла. В качестве точки соединения используется пара IP-адрес и порт.

TCP широко распространен. Сторонние системы чаще всего предоставляют именно TCP-интерфейс доступа к своим службам.

\subsubsection{Сокеты домена Unix}

Unix-сокет или IPC-сокет -- интерфейс межпроцессного взаимодействия в пределах одного узла, не использующий сетевого протокола. Может работать в разных режимах: передачи потока байт, датаграмм или последовательных пакетов. Первые два соответствуют протоколам TCP и UDP. Третий -- последовательный надежный канал для передачи датаграмм.

\subsection{Каналы}

\subsubsection{Неименованные каналы}

Неименованный канал -- однонаправленный метод межпроцессного взаимодействия для родственных процессов. Данные, записанные в неименованный канал, остаются там до момента считывания, либо до момента завершения ссылающихся на него процессов. Размер буфера ограничен.

\subsubsection{Именованные каналы}

Именованный канал отличается от неименованного тем, что представлен в виде файла, следовательно, доступен всем процессам ОС. Кроме того, время его жизни не ограничено временем жизни использующих его процессов.

\subsection{Очередь сообщений}

Очередь сообщений -- список сообщений, который хранится в пространстве ядра. Каждая очередь имеет свой уникальный идентификатор. Взаимодействие происходит путем вызовов записи и чтения сообщений.

\subsection{Разделяемая память}

Обычно в целях безопасности адресное пространство процесса изолировано от других. В некоторых случаях, однако, может быть необходимо использовать совместно один и тот же сегмент памяти. Такая память называется разделяемой. На рисунке \ref{chapter11:ShMem} приведен пример использования разделяемой памяти двумя процессами.

\begin{figure}[!h]
\caption{Пример использования разделяемой памяти}
\label{chapter11:ShMem}
%\includegraphics{../../graphics/schemes/ShMemBasic}
\tikzfig{../../graphics/schemes/ShMemBasic}
\end{figure}

Существуют два интерфейса для доступа к разделяемой памяти. Более старый System V и более новый POSIX.

\subsubsection{System V}

Разделяемая память здесь является системным ресурсом, она представлена уникальным ключом в пределах ОС.

Интерфейс реализуется через набор системных вызовов и структур для работы с ним:
\begin{itemize}
\item shmget(key\_t key, size\_t size, int oflag) -- вызов для создания нового сегмента разделяемой памяти или использования существующего с ключом \textit{key} . Размер сегмента \textit{size}, флагb доступа и создания \textit{oflag};
\item shmat(int shmid, const void *shmaddr, int flag) -- подключение сегмента в адресное пространство процесса;
\item shmdt(const void *shmaddr) -- отключение сегмента от адресного пространства;
\item shmctl(int shmid, int cmd, struct shmid\_ds *buf) -- управление разделяемой памятью: изменение прав доступа, удаление, запрос статистики;
\end{itemize}

\subsubsection{POSIX}

Разделяемая память здесь является пользовательским ресурсом, она представлена файлом.
Интерфейс реализуется через набор системных вызовов:
\begin{itemize}
\item shm\_open(const char *name, int oflag, mode\_t mode) -- открывает файл для разделяемой памяти (аналог shmget). В отличие от обычного вызова open, открытый таким образом файл не синхронизируется с диском.
\item shm\_unlink(const char *name) -- удаляет файл (аналог shmctl);
\item ftruncate(int fd, off\_t length) -- задает размер файла;
\item fstat(int fd, struct stat *statbuf) -- статистика о файле (аналог shmctl);
\item mmap(void *addr, size\_t length, int prot, int flags, int fd, off\_t offset) -- отображение файла в памяти (аналог shmat);
\item munmap(void *addr, size\_t length) -- отключает отображенный сегмент от адресного пространства процесса (аналог shmdt).
\end{itemize}

\subsubsection{Разница между System V и POSIX}
Оба интерфейса предлагают аналогичные возможности. Разница состоит в предоставлении ресурса в системе, имени файла для POSIX или целом числе в System V. Также, в POSIX интерфейсе сегмент разделяемой памяти будет уничтожен, когда будет завершен последний процесс, отображающий его в память, а файл полностью удален. Это свойство полезно на случай непредвиденного завершения процессов, например, в результате программного дефекта.

\subsection{Сравнение методов межпроцессного взаимодействия}

Приведенные выше методы можно разделить на группы по трем критериям:
\begin{itemize} 
\item способности к взаимодействию с удаленными процессами, то есть с процессами на других физических узлах;
\item использованию ядра ОС для осуществления межпроцессного взаимодействия.
\end{itemize}

Среди всех представленных методов только TCP-сокеты позволяют взаимодействовать как процессам на разных физических узлах, так и на одном узле, используя один и тот же интерфейс. Поэтому разумно использовать именно этот метод в качестве базового метода межпроцессного взаимодействия.

Все приведенные методы, за исключением разделяемой памяти, при межпроцессном взаимодействии используют ядро операционной системы. Использование ядра существенно увеличивает временную задержку на передачу данных. Как минимум, из-за двойного копирования данных, перехода между пользовательским режимом и режимом ядра (см. рисунок \ref{chapter11:KernelUsage}).
Разделяемая память же позволяет осуществлять взаимодействие напрямую через пользовательское пространство.

\begin{figure}[!h]
\caption{Общая схема межпроцессного взаимодействия при использовании ядра ОС}
\label{chapter11:KernelUsage}
\tikzfig{../../graphics/schemes/KernelUsage}
\end{figure}

Однако, сама по себе разделяемая не предоставляет возможностей для синхронизации процессов, не имеет механизма оповещения об изменении состояния разделяемой памяти. Для этого необходимо рассмотреть методы синхронизации процессов.

\section{Методы синхронизации процессов}

Методы синхронизации процессов нужны, чтобы корректно передавать данные между процессами через разделяемую память, например, не допускать состояния гонки. Можно выделить два класса методов: примитивы синхронизации и атомарные операции. Примитивы синхронизации зачастую используют в своих алгоритмах атомарные операции.

\subsection{Примитивы синхронизации}

В Linux на уровне ядра ОС поддержаны следующие примитивы межпроцессной синхронизации:
\begin{enumerate}
\item System V семафоры;
\item futex -- \textbf{f}ast \textbf{u}serspace mu\textbf{tex}.
\end{enumerate}

В свою очередь, futex служит основой для более продвинутых примитивов синхронизации:
\begin{enumerate}
\item POSIX-семафора;
\item mutex -- взаимное исключение;
\item rw-mutex -- взаимное исключение для одного писателя и множества читателей.
\end{enumerate}

Рассмотрим их подробнее.

\subsubsection{futex}

Futex \cite{FutexOrigins} -- это низкоуровневый механизм блокировок в пользовательском пространстве. В основном, операции с ним производится с помощью атомарных инструкций в пользовательском пространстве. Ядро применяется для ожидания и диспетчеризации использующих futex процессов.

В пользовательской памяти futex -- это 4-байтное число, выравненное также на 4 байта. Он может располагаться в собственном адресном пространстве процесса и использоваться для синхронизации потоков процесса, а может и в разделяемой памяти и отвечать за синхронизацию разных процессов в пределах одного физического узла. Алгоритм работы с ним устанавливается пользователем. В нужных сценариях алгоритма используется ядро разрешения состязательности, задач ожидания и диспетчеризации.

\subsubsection{Семафоры}

\paragraph{POSIX}

\paragraph{System V}

\subsubsection{Взаимные исключения}
\paragraph{Mutex}

\paragraph{RW-Mutex}


\subsection{Атомарные операции}

\textbf{TBD: это такие операции..}

Виды атомарных операций:
\begin{enumerate}
\item load/store -- атомарные чтение или запись;
\item swap -- атомарно устанавливает значение переменной и возвращает старое значение;
\item compare-and-swap -- атомарное изменение значения переменной при истинном значении предиката над переменной; \textbf{TBD: подкорректировать}
\item fetch-and-add -- атомарная арифметическая или логическая операция над переменной с возвращением предыдущего значнеия;
\end{enumerate}

\section{Предыдущая работа}

\textbf{TBD: написать про мою бакалаврскую ВКР и сослаться на электронный тезис?}

\section{Обзор литературы}

\textbf{TBD: привести аналогичные исследования в этой области. Чужие диссеры про IPC между процессами, между виртуалками. Много раз сказать, что быстрее shmem ничего нет.}

\section{Коммерческие решения}

\textbf{TBD: informatica и tibco}

\section{Значимость методов на основе разделяемой памяти в межпроцессном взаимодействия}

\textbf{TBD: Таким образом, методы на основе разделяемой памяти...}

\section{Необходимость в едином интерфейса доступа к методам межпроцессного взаимодействия}

\textbf{TBD: Чтобы методами можно было пользоваться, нужен интерфейс, интерфейс был сделан, поэтому теперь все работает через него, включая и эту работу}

\finishrelatedwork

\section{Критерий эффективности и постановка цели работы}

\textbf{TBD: временная задержка на передачу данных}
\textbf{TBD: и ее цель -- ее уменьшение в сравнении с TCP}

\chapterconclusion

\textbf{TBD: выводы}