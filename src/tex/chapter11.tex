\chapter{Обзор предметной области и постановка цели работы}

\startrelatedwork

\section{Методы межпроцессного взаимодействия}

Метод межпроцессного взаимодействия -- это способ осуществления взаимодействия процессов, находящихся на одном или разных физических узлах.

В Linux поддержаны следующие методы межпроцессного взаимодействия:
\begin{enumerate}
\item Интернет-сокеты и сокеты домена Unix.
\item именованные и неименованные каналы.
\item Очередь сообщений.
\item Разделяемая память: SystemV и POSIX.
\end{enumerate}

Рассмотрим приведенные выше методы межпроцессного взаимодействия.

\subsection{Сокеты}

Сокет -- это программный интерфейс для обеспечения обмена данными между процессами. В зависимости от реализации интерфейса, позволяет взаимодействовать процессам как на разных физических узлах в составе сети, так и в пределах одного узла. Широко распространены два вида, сокеты TCP и сокеты домена Unix. Первый работает через протокол TCP, второй -- использует некоторую внутреннюю реализацию канала связи, как и в TCP.

\subsubsection{TCP-сокеты}
TCP-сокет -- интерфейс межпроцессного взаимодействия, использующий протокол TCP. Среди всех рассматриваемых методов только он позволяет взаимодействовать процессам на разных физических узлах в составе сети. В то же время, возможно межпроцессное взаимодействие и в пределах одного узла через механизм обратной петли, когда TCP-сообщение передается без каких-либо излишних операций в процесс-получатель, не покидая физического узла. В качестве точки соединения используется пара IP-адрес и порт.

TCP широко распространен. Сторонние системы чаще всего предоставляют именно TCP-интерфейс доступа к своим службам.

\subsubsection{Сокеты домена Unix}

Unix-сокет или IPC-сокет -- интерфейс межпроцессного взаимодействия в пределах одного узла, не использующий сетевого протокола. Может работать в разных режимах: передачи потока байт, датаграмм или последовательных пакетов. Первые два соответствуют протоколам TCP и UDP. Третий -- последовательный надежный канал для передачи датаграмм.

\subsection{Каналы}

\subsubsection{Неименованные каналы}

Неименованный канал -- однонаправленный метод межпроцессного взаимодействия для родственных процессов. Данные, записанные в неименованный канал, остаются там до момента считывания, либо до момента завершения ссылающихся на него процессов. Размер буфера ограничен.

\subsubsection{Именованные каналы}

Именованный канал отличается от неименованного тем, что представлен в виде файла, следовательно, доступен всем процессам ОС. Кроме того, время его жизни не ограничено временем жизни использующих его процессов.

\subsection{Очередь сообщений}

Очередь сообщений -- список сообщений, который хранится в пространстве ядра. Каждая очередь имеет свой уникальный идентификатор. Взаимодействие происходит путем вызовов записи и чтения сообщений.

\subsection{Разделяемая память}

Обычно в целях безопасности адресное пространство процесса изолировано от других. В некоторых случаях, однако, может быть необходимо использовать совместно один и тот же сегмент памяти. Такая память называется разделяемой. На рисунке \ref{chapter11:ShMem} приведен пример использования разделяемой памяти двумя процессами.

\begin{figure}[!h]
\caption{Пример использования разделяемой памяти}
\label{chapter11:ShMem}
%\includegraphics{../../graphics/schemes/ShMemBasic}
\tikzfig{../../graphics/schemes/ShMemBasic}
\end{figure}

Существуют два интерфейса для доступа к разделяемой памяти. Более старый System V и более новый POSIX.

\subsubsection{System V}

Разделяемая память здесь является системным ресурсом, она представлена уникальным ключом в пределах ОС.

Интерфейс реализуется через набор системных вызовов и структур для работы с ним:
\begin{itemize}
\item shmget(key\_t key, size\_t size, int oflag) -- вызов для создания нового сегмента разделяемой памяти или использования существующего с ключом \textit{key} . Размер сегмента \textit{size}, флагb доступа и создания \textit{oflag};
\item shmat(int shmid, const void *shmaddr, int flag) -- подключение сегмента в адресное пространство процесса;
\item shmdt(const void *shmaddr) -- отключение сегмента от адресного пространства;
\item shmctl(int shmid, int cmd, struct shmid\_ds *buf) -- управление разделяемой памятью: изменение прав доступа, удаление, запрос статистики;
\end{itemize}

\subsubsection{POSIX}

Разделяемая память здесь является пользовательским ресурсом, она представлена файлом.
Интерфейс реализуется через набор системных вызовов:
\begin{itemize}
\item shm\_open(const char *name, int oflag, mode\_t mode) -- открывает файл для разделяемой памяти (аналог shmget). В отличие от обычного вызова open, открытый таким образом файл не синхронизируется с диском.
\item shm\_unlink(const char *name) -- удаляет файл (аналог shmctl);
\item ftruncate(int fd, off\_t length) -- задает размер файла;
\item fstat(int fd, struct stat *statbuf) -- статистика о файле (аналог shmctl);
\item mmap(void *addr, size\_t length, int prot, int flags, int fd, off\_t offset) -- отображение файла в памяти (аналог shmat);
\item munmap(void *addr, size\_t length) -- отключает отображенный сегмент от адресного пространства процесса (аналог shmdt).
\end{itemize}

\subsubsection{Разница между System V и POSIX}
Оба интерфейса предлагают аналогичные возможности. Разница состоит в предоставлении ресурса в системе, имени файла для POSIX или целом числе в System V. Также, в POSIX интерфейсе сегмент разделяемой памяти будет уничтожен, когда будет завершен последний процесс, отображающий его в память, а файл полностью удален. Это свойство полезно на случай непредвиденного завершения процессов, например, в результате программного дефекта.

\subsection{Сравнение методов межпроцессного взаимодействия}

Приведенные выше методы можно разделить на группы по трем критериям:
\begin{itemize} 
\item способности к взаимодействию с удаленными процессами, то есть с процессами на других физических узлах;
\item использованию ядра ОС для осуществления межпроцессного взаимодействия.
\end{itemize}

Среди всех представленных методов только TCP-сокеты позволяют взаимодействовать как процессам на разных физических узлах, так и на одном узле, используя один и тот же интерфейс. Поэтому разумно использовать именно этот метод в качестве базового метода межпроцессного взаимодействия.

Все приведенные методы, за исключением разделяемой памяти, при межпроцессном взаимодействии используют ядро операционной системы. Использование ядра существенно увеличивает временную задержку на передачу данных. Как минимум, из-за двойного копирования данных, перехода между пользовательским режимом и режимом ядра (см. рисунок \ref{chapter11:KernelUsage}).
Разделяемая память же позволяет осуществлять взаимодействие напрямую через пользовательское пространство.

\begin{figure}[!h]
\caption{Общая схема межпроцессного взаимодействия при использовании ядра ОС}
\label{chapter11:KernelUsage}
\tikzfig{../../graphics/schemes/KernelUsage}
\end{figure}

Однако, сама по себе разделяемая не предоставляет возможностей для синхронизации процессов, не имеет механизма оповещения об изменении состояния разделяемой памяти. Для этого необходимо рассмотреть методы синхронизации процессов.

\section{Методы синхронизации процессов}

Методы синхронизации процессов нужны, чтобы корректно передавать данные между процессами через разделяемую память, например, не допускать состояния гонки. Можно выделить два класса методов: примитивы синхронизации и атомарные операции. Примитивы синхронизации зачастую используют в своих алгоритмах атомарные операции.

\subsection{Примитивы синхронизации}

В Linux на уровне ядра ОС поддержаны следующие примитивы межпроцессной синхронизации:
\begin{enumerate}
\item System V семафоры;
\item futex -- \textbf{f}ast \textbf{u}serspace mu\textbf{tex}.
\end{enumerate}

В свою очередь, futex служит основой для более продвинутых примитивов синхронизации:
\begin{enumerate}
\item POSIX-семафора;
\item mutex -- взаимное исключение;
\item rw-mutex -- взаимное исключение для одного писателя и множества читателей.
\item spinlock -- взаимное исключение методом холостого ожидания (busy wait).
\item Условная переменная -- оповещение о наступлении события и ожидание события.
\end{enumerate}

Рассмотрим их подробнее.

\subsubsection{futex}

Futex \cite{FutexOrigins} -- это низкоуровневый механизм блокировок в пользовательском пространстве. В основном, операции с ним производится с помощью атомарных инструкций в пользовательском пространстве. Ядро применяется для ожидания и диспетчеризации использующих futex процессов.

В пользовательской памяти futex -- это 4-байтное число, выравненное также на 4 байта. Он может располагаться в собственном адресном пространстве процесса и использоваться для синхронизации потоков процесса, а может и в разделяемой памяти и отвечать за синхронизацию разных процессов в пределах одного физического узла. Алгоритм работы с ним устанавливается пользователем. В нужных сценариях алгоритма используется ядро ОС для разрешения состязательности, задач ожидания и диспетчеризации.

\subsubsection{Семафоры}

Семафор -- это примитив синхронизации на основе целочисленного счетчика. Поддерживает две операции: увеличение значения счетчика и уменьшение. Уменьшение до нуля приводит к добавлению процесса в очередь ожидания семафора. Увеличение от нуля -- к пробуждению одного из потоков из очереди ожидания.

В Linux представлены два интерфейса семафоров: System V и POSIX.

\paragraph{POSIX}

Реализованы через futex. Представляют из себя целое знаковое число. Процедуры \textit{sem\_post()} и \textit{sem\_wait()} используются для увеличения и уменьшения значения семафора, соответственно. Первая также пробуждает процессы в очереди ожидания семафора, если необходимо, вторая -- добавляет процесс в очередь ожидания, если после уменьшения значения семафора стало равно нулю или было равно  нулю.
POSIX-семафоры представлены в двух видах: именованные и неименованные. Первые идентифицируются файлом, вторые располагаются в адресном пространстве процесса или разделяемой памяти.

\paragraph{System V}

Реализованы в ядре ОС. Идентифицируются целочисленным ключом в пределах одной ОС. Имеют возможность контролировать доступ к операциям над семафором.

\subsubsection{Взаимные исключения}

Взаимное исключение -- примитив синхронизации для обеспечения эксклюзивного доступа к данным, защищенным этим примитивом. Существует несколько вариантов: обычный -- mutex, рекурсивный -- recursive mutex, с одновременным доступом нескольких читателей -- read/write-mutex. По определению, mutex может освободить только тот поток, который его занял.

В Linux реализованы через futex. Предоставляются посредством библиотеки \textit{pthread}.

\paragraph{Mutex}
Классический механизм взаимного исключения. Представлен платформо-зависимым типом данных \textit{pthread\_mutex\_t} Используется через семейство функций библиотеки \textit{pthread} -- \textit{pthread\_mutex\_*}.

\paragraph{RW-Mutex}
Версия взаимного исключения, допускающая совместное нахождение в критической секции нескольких читателей, но требующая эксклюзивного доступа для писателя. Представлена платформо-зависимым типом данных \textit{pthread\_rwlock\_t} Используется через семейство функций библиотеки \textit{pthread} -- \textit{pthread\_rwlock\_*}.

\paragraph{Spinlock}
Реализация механизма взаимного исключение с использованием механизма холостого ожидания. Взятие блокировки состоит в изменение значения переменной на условные "свободно" и "занято", а ожидание -- в непрерывном циклическом ожидании наступления состояния "свободно".

\subsubsection{Условная переменная}

Условная переменная -- примитив синхронизации. Обеспечивает блокирование одного или нескольких потоков до наступления события о выполнения предиката. Представлена платформо-зависимым типом данных \textit{pthread\_cond\_t}. Используется через семейство функций библиотеки \textit{pthread} -- \textit{pthread\_cond\_*}. Условная переменная используется вместе с mutex, который обеспечивает синхронизированный доступ к параметрам предиката и другим данным.

В Linux примитив также реализован через futex.

\subsection{Сравнение методов межпроцессной синхронизации}

\textbf{TBD: прямо сравнение? Выбрать нормальное название раздела}

Наиболее универсальный из рассмотренных классических примитивов синхронизации -- это семафор. Используя его можно реализовать как взаимное исключение, так и условную переменную. Он подходит для решения задачи читателей и писателя (или производителя и потребителей), как и комбинация условной переменной с mutex.

Как можно заметить, почти все рассмотренные примитивы в Linux реализованы через futex. Он может быть полезен при разработке своих собственных специализированных примитивов синхронизации \cite{FutexesAreTricky}.

\subsection{Атомарные операции}

Атомарная операция -- это операция, которая выполняется исключительно целиком, либо не выполняется вовсе. В настоящей работе рассматриваются именно простейшие операции. Они используются через стандартную библиотеку языка C++ как набор классов \textit{std::atomic}.

Виды атомарных операций:
\begin{enumerate}
\item load/store -- атомарные чтение или запись;
\item swap -- атомарно устанавливает значение переменной и возвращает старое значение;
\item compare-and-swap -- атомарное изменение значения переменной, если ее текущее состояние совпадает с ожидаемым;
\item fetch-and-(add/dec/or/and) -- атомарная арифметическая или логическая операция над переменной с возвращением предыдущего значения.
\end{enumerate}

Атомарные операции используются при разработке методов синхронизации и неблокирующих алгоритмов, структур данных с конкурентным доступом. Даже в простейшей реализации взаимного исключения, в spinlock, исполнение в критической секции требует двух атомарных операций на взятие и освобождение. Если внутри критической секции необходимо, например, выставить бит в 4-байтной переменной, то можно сделать это, используя атомарную операцию fetch-and-or. 

Вместе с futex они являются наиболее низкоуровневыми блоками для построения методов межпроцессной синхронизации.

\section{Предыдущая работа}

В ранних работах автора была разработана и реализована прикладная программная платформа для эффективного взаимодействия процессов \cite{GubarevKMU18} по модели ''точка-точка``. Разработан и реализован метод эффективного межпроцессного взаимодействия посредством мультиплексора в разделяемой памяти \cite{GubarevKMU20}. Этот метод предоставляется через реализованную ранее прикладную программную платформу, то есть не требует со стороны программиста никаких изменений в программном коде для использования разработанного метода.
\textbf{TBD: может, убрать все цитирования ВКР? А еще мультиплексор -- это не предыдущая, а очень даже свежая работа.}

\section{Обзор литературы}

\subsection{Научные работы}
\textbf{TBD: подумать над названием раздела}
Во множестве работ предлагаются методы эффективного межпроцессного взаимодействия, системы передачи сообщений между процессами в различных применениях. В подавляющем большинстве работ в качестве среды для передачи данных используется разделяемая память.

Авторы в работе \cite{7790679} предлагают гетерогенную систему для передачи сообщений по модели ''издатель/подписчики``. Посредством очереди разделяемой памяти данные передаются между процессами, написанными на разных языка: Python и C++. Синхронизация и ожидание данных осуществляется через семафор.

В работе \cite{ShMemTransportThesis} представлена система для передачи сообщений, использующая разделяемую память для взаимодействия процессов в пределах одного узла и TCP -- с удаленными процессами. Поддержаны взаимодействия как по модели ''точка-точка``, так и ``издатель/подписчики''. Система предоставляет единый интерфейс межпроцессного взаимодействия, то есть использование того или иного метода не требует изменения исходного кода программистом.

В параллельных вычислениях широко используется MPI -- Message Passing Interface. Это программный интерфейс для взаимодействия процессов посредством передачи сообщений. В ряде работ предлагаются различные методы межпроцессного взаимодействия на основе разделяемой памяти с целью увеличения производительности параллельных систем в различных реализациях MPI, например, MPICH2 \cite{10.1007/11846802_19, 8665755} или MVAPICH2 \cite{4100356, 4663761}.

В работе \cite{HPCInterCoreLinux} предлагается метод эффективного межпроцессного взаимодействия с использованием разделяемой памяти для встраиваемых многоядерных систем, где необходимы одновременно производительные и не ресурсоемкие методы.

Существуют работы об использовании разделяемой памяти для взаимодействия процессов в разных виртуальных машинах в пределах машины-хозяина \cite{IPCInterVirtualMachineShmem, IPCInterVirtualMachineShmemOptimizations, 10.1145/2847562, 10.1007/978-3-642-00955-6_7}. В том числе работа \cite{234795}, в которой разделяемая память используется как для взаимодействия процессов на одном физическом узле, так и на разных в пределах кластера через удаленный прямой доступ в память (RDMA), что требует специального оборудования. В работе \cite{7416013} авторы используют разделяемую память для повышения производительности взаимодействия виртуальных машин на одном физическом узле через сокеты (TCP и UDP).

Эффективное межпроцессное взаимодействие также важно в роботизированных системах. Так, в работе \cite{5649358} предлагается система передачи сообщений по модели ''издатель/подписчики`` посредством UDP-мультивещания с целью добиться минимальной временной задержки на передачу данных. Метод межпроцессного взаимодействия через разделяемую память предлагается в работе \cite{Wang2019TZCEI}, где авторы предлагают систему ''издатель/подписчик`` с передачей управляющего блока данных через сокеты, а сами данные через разделяемую память без преобразования сериализации передаваемого объекта.

В различных работах исследуется производительность механизмов операционных систем для межпроцессного взаимодействия. В работе \cite{MuxComparison} сравниваются системные мультиплексоры событий \textit{select, epoll и poll}. В работе \cite{AnalysisOfEventProcDesignPatterns} проведен анализ влияния специфики работы этих механизмов на производительность методов обслуживания соединений ''Лидер/Последователи`` и ``Полусинхронный/Полуасинхронный``. А в работе \cite{6298185} были предложены марковские модели этих методов обслуживания.
\textbf{TBD: нужны ли мне модели тут?}
%В работах \cite{Smith2012DraftH, venkataraman2015evaluation} произведен анализ и сравнение различных методов межпроцессного взаимодействия в Linux: каналов, различных реализаций на основе разделяемой памяти, сокетов домена UNIX и TCP.
В работах \cite{Smith2012DraftH, venkataraman2015evaluation} в Linux показано превосходство методов межпроцессного взаимодействия на основе разделяемой памяти над каналами, TCP и сокетами домена Unix.
В работе \cite{8526899} исследуются механизмы пробуждения потоков для обслуживания асинхронных событий и предлагается метод существенного уменьшения временной задержки на пробуждение потока для обслуживания асинхронного события, используя привилегированные возможности аппаратного обеспечения.

\subsection{Коммерческие решения для передачи сообщений}

Наиболее известные высокопроизводительные решения для передачи сообщений между процессами -- это системы от компаний TIBCO \cite{TIBCO}, Informatica \cite{Informatica} и Solace \cite{Solace}. Они представляют собой целостные решения организации обмена сообщениями между процессами распределенной системы. А для передачи данных между процессами в пределах одного физического узла используют методы на основе разделяемой памяти.
\textbf{TBD: а надо ли оно мне?}

\section{Значимость методов на основе разделяемой памяти в межпроцессном взаимодействия}

Исходя из выше перечисленного, методы на основе разделяемой памяти имеют большое значение в современных системах обмена сообщениями. Они позволяют передавать сообщения между процессами с минимальной временной задержкой.

\section{Важность единого интерфейса межпроцессного взаимодействия}

Крайне важно соблюдать единый и неизменный интерфейс межпроцессного взаимодействия. Внедрение новых методов межпроцессного взаимодействия не должно приводить к изменениям в пользовательском исходном коде. Поэтому методы, разрабатываемые в настоящей работе, должны соблюдать ранее представленный интерфейс межпроцессного взаимодействия \cite{GubarevKMU18}.

\finishrelatedwork

\section{Критерий эффективности и постановка цели}

В настоящей работе критерием эффективности принята временная задержка на передачу данных. Чем она меньше, тем более эффективным считается метод межпроцессного в взаимодействия.
Цель работы -- уменьшение временной задержки на передачу данных между процессами в пределах одного физического узла по сравнению с TCP путем разработки и применения более эффективных методов межпроцессного взаимодействия.

Чтобы уменьшить временную задержку на передачу данных, необходимо разработать и реализовать новые, более эффективные методы межпроцессного взаимодействия, чем представленные автором \textbf{TBD: автором?} ранее. Они должны быть построены на основе очереди в разделяемой памяти и использовать более эффективные методы оповещения о появлении данных в этой разделяемой памяти, чем TCP.

Из проведенного сравнения методов межпроцессного взаимодействия и синхронизации и обзора литературы следует, что сама по себе разделяемая память является очень производительным методом межпроцессного взаимодействия. Однако, она не предоставляет механизмов синхронизации и отслеживания событий в ней. Поэтому необходимо также разработать и реализовать эффективный метод оповещения о появлении данных в разделяемой памяти.

Необходимо экспериментально исследовать разработанные методы межпроцессного взаимодействия и сравнить их с предложенным ранее методом с использованием разделяемой памяти и TCP для оповещения о наличии данных в очереди.

Новые методы должны следовать разработанному ранее интерфейсу межпроцессного взаимодействия и не требовать изменений в пользовательском коде.